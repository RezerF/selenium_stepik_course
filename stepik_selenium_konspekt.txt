Поэтому предлагаем вам простое правило: если увидите нечеловекочитаемое значение атрибута или если значение атрибута меняется 
при перезагрузке страницы, то не используйте его. В наших примерах мы используем статические страницы, поэтому вы смело можете 
использовать описанные здесь CSS-селекторы.

Поиск по id
Какое везение! У элемента с нашей картинкой есть атрибут id="bullet", а значит, мы однозначно можем найти её с помощью 
cелектора #bullet (знак # означает, что мы ищем по id со значением bullet).

Поиск по tag
Чтобы найти элемент по тегу, просто напишите название тега в поисковой строке, как мы делали это при поиске по id (только без знака #), 
например, h1. Поиск по h1 найдёт для нас элемент с названием страницы. Поиск по тегам не очень удобен, т.к. разработчики используют небольшое количество
 тегов для разметки страниц, и скорее всего, одному тегу будет соответствовать множество элементов.

Поиск по значению атрибута
Можно найти элемент, указав название атрибута и его значение. Например, можно переписать поиск по id в следующем виде [id="bullet"] вместо #bullet.

Поиск по name
Этот вариант поиска является разновидностью поиска по значению атрибута и записывается так же: [name="bullet-cat"]. Мы выделяем этот вариант потому что он довольно часто 
используется, а также выделяется как отдельный вид поиска элементов в Selenium WebDriver.

Поиск по class
Поиск по классу можно записать в виде [class="jumbotron-heading"], так как class тоже является атрибутом элемента. Но раз уж классы используются практически
 в каждой странице при задании стилей страниц, то для них также имеется свой короткий вариант поиска: .jumbotron-heading. То есть мы пишем значение класса и 
предваряем его точкой.Вариант [class="lead"] не найдет нам этот элемент, так как он ищет по точному совпадению. Чтобы найти элемент, нам нужно будет 
написать [class="lead text-muted"], порядок классов при этом важен. [class="text-muted lead"] - уже не найдет искомый элемент.
Вариант .lead при этом позволит найти данный элемент, так как он ищет простое вхождение класса в элемент. Для уточнения селектора можно задать также оба класса, 
для этого нужно добавить второй класс к строке поиска без пробела и предварить его точкой: .lead.text-muted. Порядок классов в отличие от первого способа здесь 
не важен - .text-muted.lead также найдет нужный элемент. Рекомендуем пользоваться вторым способом поиска классов, так как он является более гибким.
Еще одно важное замечание. Поиск по классу чувствителен к регистру, то есть .Lead уже не найдет нужный элемент.

"#post2 .title"

Здесь знак "#" означает, что надо искать элемент с id "post2", а "." - что искать надо класс со значением "title".
Элемент ".title" называется потомком (англ. descendant) элемента "#post2". Потомок может находиться на любом уровне вложенности - все элементы 
с селектором ".title" также являются и потомками элемента "#posts", хотя и расположены от него на два уровня ниже. "#posts .title" найдет все 3 элемента 
с классом "title".
!Внимание. Символ пробела " " является значащим в CSS-селекторах. Это важный символ, который разделяет описание предка и потомка. Если бы мы записали 
селектор "#post2.title" без пробела, то в данном примере не было найдено ни одного элемента. Такая запись означала бы, что мы хотим найти элемент, 
который одновременно содержит id "post2" и класс "title". То есть "#post2 .title" и "#post2.title" - это разные селекторы.

Использование потомков

Попробуем найти элемент с текстом "Ходили купаться". Для решения этой задачи мы можем взять элемент, стоящий выше в иерархии нужного нам элемента,
 и написать следующий селектор:
"#post2 .title"
Здесь знак "#" означает, что надо искать элемент с id "post2", а "." - что искать надо класс со значением "title".
Элемент ".title" называется потомком (англ. descendant) элемента "#post2". Потомок может находиться на любом уровне вложенности - все элементы с 
селектором ".title" также являются и потомками элемента "#posts", хотя и расположены от него на два уровня ниже. "#posts .title" найдет все 3 элемента
 с классом "title".

!Внимание. Символ пробела " " является значащим в CSS-селекторах. Это важный символ, который разделяет описание предка и потомка.
 Если бы мы записали селектор "#post2.title" без пробела, то в данном примере не было найдено ни одного элемента. Такая запись означала бы, что мы хотим найти
 элемент, который одновременно содержит id "post2" и класс "title". То есть "#post2 .title" и "#post2.title" - это разные селекторы.

Использование дочерних элементов
Другой способ найти этот элемент:
"#post2 > div.title"
Здесь мы указали еще тег элемента div и уточнили, что нужно взять элемент с тегом и классом: "div.title", который находится строго на один уровень иерархии
 ниже чем элемент "#post2" (это задаёт символ ">").
Элемент "#post2" в этом случае называется родителем (англ. parent) для элемента "div.title", а элемент "div.title" называется дочерним элементом (англ. child) 
для элемента "#post2". Если символа ">" нет, то будут выполнен поиск всех элементов "div.title" на любом уровне ниже первого элемента.

!Внимание. В данном случае символы пробела вокруг символа ">" не несут важного значения в отличие от предыдущего примера, и могут быть опущены. Запись "#post2>div.title" аналогична записи "#post2 > div.title".

Использование порядкового номера дочернего элемента
Еще один способ найти этот элемент:
"#posts > .item:nth-child(2) > .title"
Псевдо-класс :nth-child(2) - позволяет найти второй по порядку элемент среди дочерних элементов для "#posts". Затем с помощью "> .title" мы указываем,
 что нам нужен элемент ".title", родителем которого является найденный ранее элемент ".item".

Использование нескольких классов
Также мы можем использовать сразу несколько классов элемента, чтобы его найти. Для этого классы записываются подряд через точку: ".title.second"

find_element_by_id - поиск по уникальному атрибуту id элемента. Если ваши разработчики проставляют всем элементам в приложении уникальный id, то вам повезло, и вы чаще всего будет использовать этот метод, так как он наиболее стабильный;
find_element_by_css_selector - поиск элемента с помощью правил на основе CSS. Это универсальный метод поиска, так как большинство веб-приложений использует CSS для вёрстки и задания оформления страницам. Если find_element_by_id вам не подходит из-за отсутствия id у элементов, то скорее всего вы будете использовать именно этот метод в ваших тестах;
find_element_by_xpath - поиск с помощью языка запросов XPath, позволяет выполнять очень гибкий поиск элементов;
find_element_by_name - поиск по атрибуту name элемента;
find_element_by_tag_name - поиск элемента по названию тега элемента;
find_element_by_class_name - поиск по значению атрибута class;
find_element_by_link_text - поиск ссылки на странице по полному совпадению;
find_element_by_partial_link_text - поиск ссылки на странице, если текст селектора совпадает с любой частью текста ссылки


By.ID – поиск по уникальному атрибуту id элемента;
By.CSS_SELECTOR – поиск элементов с помощью правил на основе CSS;
By.XPATH – поиск элементов с помощью языка запросов XPath;
By.NAME – поиск по атрибуту name элемента;
By.TAG_NAME – поиск по названию тега;
By.CLASS_NAME – поиск по атрибуту class элемента;
By.LINK_TEXT – поиск ссылки с указанным текстом. Текст ссылки должен быть точным совпадением;
By.PARTIAL_LINK_TEXT – поиск ссылки по частичному совпадению текста.

Поиск элементов с помощью XPath
В работе с веб-страницами не всегда получается найти селектор, однозначно описывающий путь к нужному элементу. В такой ситуации для тестировщика лучшим 
решением проблемы будет пойти к фронтенд-разработчику проекта и договориться о специальном атрибуте, который будет использоваться в автотестах. Таким образом 
можно повысить тестируемость приложения. Увы, проекты бывают разные, и не всегда это возможно. И когда другого выхода больше нет, а автоматизировать как-то надо, 
можно обратиться к помощи языка запросов XPath.
На тему XPath мнения расходятся, но, как бы то ни было, это мощный и гибкий инструмент, который позволяет писать сложные запросы для поиска элементов.

Прежде всего, XPath (XML Path Language) это язык запросов, который использует древовидную структуру документа. Проверять XPath-запросы можно точно так же как
 и CSS-селекторы - в консоли разработчика. Откройте консоль на странице с котиками http://suninjuly.github.io/cats.html, и давайте на её примере разберемся в 
основах синтаксиса. Попробуйте вбить каждый из запросов-примеров в строку поиска, чтобы увидеть, что именно находит поисковый запрос.

 1. XPath запрос всегда начинается с символа / или //
Символ / аналогичен символу > в CSS-селекторе, а символ // - пробелу. Их смысл:
el1/el2 - выбирает элементы el2, являющиеся прямыми потомками el1;
el1//el2 - выбирает элементы el2, являющиеся потомками el1 любой степени вложенности.
Разница состоит в том, что в XPath, когда мы начинаем запрос с символа /,  мы должны указать элемент, являющийся корнем нашего документа. Корнем всегда будет
 элемент с тегом <html>. Пример: /html/body/header
Мы можем начинать запрос и с символа //. Это будет означать, что мы хотим найти всех потомков корневого элемента без указания корневого элемента. В этом случае, 
для поиска того же хедера, мы можем выполнить запрос //header, так как других заголовков у нас нет.
Важно! Такой поиск может быть неоднозначным. Например, запрос //div вернет вам все элементы с тегом <div>. Избегайте неоднозначных ситуаций, они плохо 
влияют на здоровье ваших автотестов.

2. Символ [ ] - это команда фильтрации
Если по запросу найдено несколько элементов, то будет произведена фильтрация по правилу, указанному в скобках.

Правил фильтрации очень много:

по любому атрибуту, будь то id, class, title (или любой другой). Например, мы хотим найти картинку с летящим котом, для этого можно выполнить запрос //img[@id='bullet']
по порядковому номеру. Допустим, мы хотим выбрать вторую по порядку карточку с котом. Для этого найдем элемент с классом "row" и возьмем его второго потомка: //div[@class="row"]/div[2]
по полному совпадению текста. Да, XPath - это единственный способ найти элемент по внутреннему тексту. Если мы хотим найти блок текста с котом-Лениным, можно 
воспользоваться XPath селектором //p[text()="Lenin cat"]. Такой селектор вернет элемент, только если текст полностью совпадет. Здесь важно сказать, что не всегда
 поиск по тексту - это хорошая практика, особенно в случае мультиязычных сайтов.
по частичному совпадению текста или атрибута. Для этого нужна функция contains. Запрос //p[contains(text(), "cat")] вернет нам все абзацы текста, которые содержат
 слово cat. Точно так же можно искать по частичному совпадению других атрибутов, это удобно, если у элемента несколько классов. Посмотрите на код навбара сайта с 
котами. Его можно найти селектором //div[contains(@class, "navbar")]
в фильтрации еще можно использовать булевы операции (and, or, not) и некоторые простые арифметические выражения (но вообще не стоит, наверное). Допустим,
 мы хотим найти картинку обязательно с data-type "animal" и именем "bullet-cat", для этого подойдет запрос: //img[@name='bullet-cat' and @data-type='animal']
 3. Символ * - команда выбора всех элементов
Например можем найти текст в заголовке запросом //div/*[@class="jumbotron-heading"]. Это может быть удобно, когда мы не знаем точно тег элемента, который ищем.
4. Поиск по классу в XPath регистрозависим
Также как и в случае поиска по CSS-селектором будьте внимательными к регистру при поиске по классам: 

//div/*[@class="Jumbotron-heading"] не найдет элемент на нашей странице.

 

Что важно знать про XPath, чтобы пользоваться им безболезненно:

Не используйте селекторы вида //div[1]/div[2]/div[3] без крайней нужды: по такому селектору невозможно с первого раза понять, что за элемент вы ищете. 
А когда структура страницы хоть немного изменится, то ваш селектор с большой вероятностью перестанет работать;
Если есть возможность использовать CSS-селекторы: сlass, id или name - лучше использовать их вместо поиска по XPath;
Можно искать по полному или частичному совпадению текста или любого атрибута;
Можно использовать булевы операции и простую арифметику;
Можно удобно перемещаться по структуре документа (переходить к потомкам и к родителям);
Подойдет, когда у сайта всё плохо с атрибутами и нет возможности достучаться до разработчиков;
Есть мнение, что поиск по XPath в среднем медленнее, чем по css. Но достоверно это неизвестно;
Не стоит использовать разные расширения для браузеров по поиску XPath: они подбирают нечитабельные и переусложненные селекторы. Лучше потратить немного
 времени и разобраться в синтаксисе самостоятельно, тем более, что он не очень сложный.




Если вам нужен не первый, а второй или следующие элементы, вам нужно либо задать более точный селектор для поиска, либо использовать методы find_elements_by.

Если вы уже пробовали запускать примеры скриптов, то могли заметить, что браузер не всегда закрывается после выполнения кода. Поэтому обратите внимание на то 
что необходимо явно закрывать окно браузера в нашем коде при помощи команды browser.quit(). Каждый раз при открытии браузера browser = webdriver.Chrome() 
в системе создается процесс, который останется висеть, если вы вручную закроете окно браузера. browser.close() закрывает текущее окно браузера

Иногда возникает ситуация, когда у нас есть несколько одинаковых по сути объектов на странице, например, иконки товаров в корзине интернет-магазина. В тесте нам
 нужно проверить, что отображаются все выбранные для покупки товары. Для этого существуют методы find_elements_by, которые в отличие от find_element_by вернут список 
всех найденных элементов по заданному условию. Проверив длину списка, мы можем удостовериться, что в корзине отобразилось правильное количество товаров.

Оба этих элемента создаются при помощи тега input со значением атрибута type равным checkbox или radio соответственно. В html-коде страницы вы увидите:

<input type="checkbox">
<input type="radio">
Если checkbox или radiobutton выбран, то у элемента появится новый атрибут checked без значения. Часто атрибут checked уже установлен для одного из элементов 
по умолчанию.

<input type="checkbox" checked>
<input type="radio" checked>
Radiobuttons объединяются в группу, где все элементы имеют одинаковые значения атрибута name, но разные значения атрибута value:

<input type="radio" name="language" value="python" checked>
<input type="radio" name="language" value="selenium">
Checkboxes могут иметь как одинаковые, так и разные значения атрибута name. Поэтому и те, и другие лучше искать с помощью значения id или значения атрибута value. 
Если вы видите на странице чекбокс с уникальным значением name, то можете искать по name.

Также вы можете увидеть тег label рядом с input. Этот тег используется, чтобы сделать кликабельным текст, который отображается рядом с флажком.
 Этот текст заключен внутри тега label. Элемент label связывается с элементом input с помощью атрибута for, в котором указывается значение 
атрибута id для элемента input:
  <input type="radio" id="python" name="language" checked>
  <label for="python">Python</label>
В этом случае можно также отметить нужный checkbox с помощью WebDriver, выполнив метод click() на элементе label.


Значение атрибута представляет собой строку. Если значение атрибута отсутствует, то это равносильно значению атрибута равному "false".
Найдём атрибут "checked" с помощью встроенного метода get_attribute и проверим его значение:
people_checked = people_radio.get_attribute("checked")
print("value of people radio: ", people_checked)
assert people_checked is not None, "People radio is not selected by default"
Т.к. у данного атрибута значение не указано явно, то метод get_attribute вернёт "true". Возможно, вы заметили, что "true" написано с маленькой буквы, — все 
методы WebDriver взаимодействуют с браузером с помощью JavaScript, в котором булевые значения пишутся с маленькой буквы, а не с большой, как в Python.
Мы можем написать проверку другим способом, сравнив строки:
assert people_checked == "true", "People radio is not selected by default"
Если атрибута нет, то метод get_attribute вернёт значение None. Применим метод get_attribute ко второму radiobutton, и убедимся, что атрибут отсутствует.
robots_radio = browser.find_element_by_id("robotsRule")
robots_checked = robots_radio.get_attribute("checked")
assert robots_checked is None

Так же мы можем проверять наличие атрибута disabled, который определяет, может ли пользователь взаимодействовать с элементом. Например, в предыдущем задании 
на странице с капчей для роботов JavaScript устанавливает атрибут disabled у кнопки Submit, когда истекает время, отведенное на решение задачи.
<button type="submit" class="btn btn-default" disabled>Submit</button>

На веб-страницах мы также встречаем раскрывающиеся (выпадающие) списки. У таких списков есть несколько важных особенностей:

У каждого элемента списка обычно есть уникальное значение атрибута value
В списках может быть разрешено выбирать как только один, так и несколько вариантов, в зависимости от типа списка
Визуально списки могут различаться тем, что в одном случае все варианты скрыты в выпадающем меню (http://suninjuly.github.io/selects1.html),
 а в другом все варианты или их часть видны (http://suninjuly.github.io/selects2.html)
Но для взаимодействия с любым вариантом списка мы будем использовать одни и те же методы Selenium.
Посмотрим, как выглядит html для списка:
<label for="dropdown">Выберите язык программирования:</label>
<select id="dropdown" class="custom-select">
 <option selected>--</option>
 <option value="1">Python</option>
 <option value="2">Java</option>
 <option value="3">JavaScript</option>
</select>
Варианты ответа задаются тегом option, значение value может отсутствовать. Можно отмечать варианты с помощью обычного метода click(). Для этого сначала нужно 
применить метод click() для элемента с тегом select, чтобы список раскрылся, а затем кликнуть на нужный вариант ответа:
from selenium import webdriver
browser = webdriver.Chrome()
browser.get(link)
browser.find_element_by_tag_name("select").click()
browser.find_element_by_css_selector("option:nth-child(2)").click()

Последняя строчка может выглядеть и так:
browser.find_element_by_css_selector("[value='1']").click()

Это не самый удобный способ, так как нам приходится делать лишний клик для открытия списка.
Есть более удобный способ, для которого используется специальный класс Select из библиотеки WebDriver. Вначале мы должны инициализировать новый объект, передав 
в него WebElement с тегом select. Далее можно найти любой вариант из списка с помощью метода select_by_value(value):
from selenium.webdriver.support.ui import Select
select = Select(browser.find_element_by_tag_name("select"))
select.select_by_value("1") # ищем элемент с текстом "Python"

Можно использовать еще два метода: select.select_by_visible_text("text") и select.select_by_index(index). Первый способ ищет элемент по видимому тексту, 
например, select.select_by_visible_text("Python") найдёт "Python" для нашего примера.
Второй способ ищет элемент по его индексу или порядковому номеру. Индексация начинается с нуля. Для того чтобы найти элемент с текстом "Python", нужно 
использовать select.select_by_index(1), так как опция с индексом 0 в данном примере имеет значение по умолчанию равное "--".

Прежде чем использовать данный скрипт в тестах, вы можете проверить, как он работает прямо в браузере, выполнив код в консоли браузера. Затем можете добавить
 его в ваш автотест с помощью execute_script(javascript_code).
Давайте попробуем вызвать alert в браузере с помощью WebDriver. Пример сценария:
from selenium import webdriver
browser = webdriver.Chrome()
browser.execute_script("alert('Robots at work');")

browser.execute_script("document.title='Script executing';")

=================================================
Если мы столкнулись с такой ситуацией, мы можем заставить браузер дополнительно проскролить нужный элемент, чтобы он точно стал видимым.
Делается это с помощью следующего скрипта:
"return arguments[0].scrollIntoView(true);"
Мы дополнительно передали в метод scrollIntoView аргумент true, чтобы элемент после скролла оказался в области видимости. Другие возможные параметры метода 
можно посмотреть здесь: https://developer.mozilla.org/ru/docs/Web/API/Element/scrollIntoView
В итоге, чтобы кликнуть на перекрытую кнопку, нам нужно выполнить следующие команды в коде:
button = browser.find_element_by_tag_name("button")
browser.execute_script("return arguments[0].scrollIntoView(true);", button)
button.click()
В метод execute_script мы передали текст js-скрипта и найденный элемент button, к которому нужно будет проскролить страницу. После выполнения кода элемент button
 должен оказаться в верхней части страницы. Подробнее о методе см https://developer.mozilla.org/ru/docs/Web/API/Element/scrollIntoView.
Также можно проскролить всю страницу целиком на строго заданное количество пикселей. Эта команда проскроллит страницу на 100 пикселей вниз:
browser.execute_script("window.scrollBy(0, 100);")

import os 
current_dir = os.path.abspath(os.path.dirname(__file__))    # получаем путь к директории текущего исполняемого файла 
file_path = os.path.join(current_dir, 'file.txt')           # добавляем к этому пути имя файла 
element.send_keys(file_path)
Подробнее о методах модуля os можете почитать самостоятельно в документации: https://docs.python.org/3/library/os.path.html. 
Элемент в форме, который выглядит, как кнопка добавления файла, имеет атрибут type="file". Мы должны сначала найти этот элемент с помощью селектора, а 
затем применить к нему метод send_keys(file_path).



====================================Урок 2.3. Работа с окнами(alert, prompt..)=========================

Теперь рассмотрим ситуацию, когда в сценарии теста возникает необходимость не только получить содержимое alert, но и нажать кнопку OK, чтобы закрыть alert.
 Alert является модальным окном: это означает, что пользователь не может взаимодействовать дальше с интерфейсом, пока не закроет alert. Для этого нужно сначала
 переключиться на окно с alert, а затем принять его с помощью команды accept():
alert = browser.switch_to.alert
alert.accept()

Чтобы получить текст из alert, используйте свойство text объекта alert:
alert = browser.switch_to.alert
alert_text = alert.text

Другой вариант модального окна, который предлагает пользователю выбор согласиться с сообщением или отказаться от него, называется confirm. Для переключения
 на окно confirm используется та же команда, что и в случае с alert:
confirm = browser.switch_to.alert
confirm.accept()

Для confirm-окон можно использовать следующий метод для отказа:
confirm.dismiss()
То же самое, что и при нажатии пользователем кнопки "Отмена". 

Третий вариант модального окна — prompt — имеет дополнительное поле для ввода текста. Чтобы ввести текст, используйте метод send_keys():
prompt = browser.switch_to.alert
prompt.send_keys("My answer")
prompt.accept()

===============================
При работе с веб-приложениями приходится переходить по ссылкам, которые открываются в новой вкладке браузера. WebDriver может работать только с одной 
вкладкой браузера. При открытии новой вкладки WebDriver продолжит работать со старой вкладкой. Для переключения на новую вкладку надо явно указать, на какую
 вкладку мы хотим перейти. Это делается с помощью команды switch_to.window:
browser.switch_to.window(window_name)
Чтобы узнать имя новой вкладки, нужно использовать метод window_handles, который возвращает массив имён всех вкладок. Зная, что в браузере теперь открыто две 
вкладки, выбираем вторую вкладку:
new_window = browser.window_handles[1]
Также мы можем запомнить имя текущей вкладки, чтобы иметь возможность потом к ней вернуться:
first_window = browser.window_handles[0]

=========================================Ожидания(Урок 2.4)======================================
В Selenium WebDriver есть специальный способ организации такого ожидания, который позволяет задать ожидание при инициализации драйвера, чтобы применить 
его ко всем тестам. Ожидание называется неявным (Implicit wait), так как его не надо явно указывать каждый раз, когда мы выполняем поиск элементов, оно
 автоматически будет применяться при вызове каждой последующей команды.
browser.implicitly_wait(5)

Теперь мы знаем, как настроить ожидание поиска элемента. Во время поиска WebDriver каждые 0.5 секунды проверяет, появился ли нужный элемент в DOM-модели браузера 
(Document Object Model — «объектная модель документа», интерфейс для доступа к HTML-содержимому сайта). Если произойдет ошибка, то WebDriver выбросит одно из 
следующих исключений (exceptions):
Если элемент не был найден за отведенное время, то мы получим NoSuchElementException.
Если элемент был найден в момент поиска, но при последующем обращении к элементу DOM изменился, то получим StaleElementReferenceException. Например, мы нашли элемент
 Кнопка и через какое-то время решили выполнить с ним уже известный нам метод click. Если кнопка за это время была скрыта скриптом, то метод применять уже бесполезно
 — элемент "устарел" (stale) и мы увидим исключение.
Если элемент был найден в момент поиска, но сам элемент невидим (например, имеет нулевые размеры), и реальный пользователь не смог бы с ним взаимодействовать, 
то получим ElementNotVisibleException.

Чтобы тест был надежным, нам нужно не только найти кнопку на странице, но и дождаться, когда кнопка станет кликабельной. Для реализации подобных ожиданий в 
Selenium WebDriver существует понятие явных ожиданий (Explicit Waits), которые позволяют задать специальное ожидание для конкретного элемента. Задание явных 
ожиданий реализуется с помощью инструментов WebDriverWait и expected_conditions. Улучшим наш тест:
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium import webdriver
browser = webdriver.Chrome()
browser.get("http://suninjuly.github.io/wait2.html")
# говорим Selenium проверять в течение 5 секунд, пока кнопка не станет кликабельной
button = WebDriverWait(browser, 5).until(
        EC.element_to_be_clickable((By.ID, "verify"))
    )
button.click()
message = browser.find_element_by_id("verify_message")
assert "successful" in message.text

Как вы видите, в этом случае нужно использовать поиск элементов с помощью класса By, который мы рассмотрели ранее. element_to_be_clickable вернет элемент, когда 
он станет кликабельным, или вернет False в ином случае.

Обратите внимание, что в объекте WebDriverWait используется функция until, в которую передается правило ожидания, элемент, а так же значение, по которому мы 
будем искать элемент. В модуле expected_conditions есть много других правил, которые позволяют реализовать необходимые ожидания:
title_is
title_contains
presence_of_element_located
visibility_of_element_located
visibility_of
presence_of_all_elements_located
text_to_be_present_in_element
text_to_be_present_in_element_value
frame_to_be_available_and_switch_to_it
invisibility_of_element_located
element_to_be_clickable
staleness_of
element_to_be_selected
element_located_to_be_selected
element_selection_state_to_be
element_located_selection_state_to_be
alert_is_present
Описание каждого правила можно найти на сайте.

Если мы захотим проверять, что кнопка становится неактивной после отправки данных, то можно задать негативное правило с помощью метода until_not:
# говорим Selenium проверять в течение 5 секунд пока кнопка станет неактивной
button = WebDriverWait(browser, 5).until_not(
        EC.element_to_be_clickable((By.ID, "verify"))
    )
text_to_be_present_in_element ожидает появление элемента, ищет его по текстовому значению. мы уже использовали этот метод в задании, когда бронировали дом и
 ждали, пока цена упадет до 100$.
text_to_be_present_in_element_value ищет по тексту из атрибута value. 


Урок 3.2 шаг 6. Assert
assert expected_result == actual_result, f'expected {expected_result}, got {actual_result}'

Иногда при работе с текстами не нужны жёсткие проверки на полное совпадение, и требуется проверить, что некий текст является подстрокой другого текста. 
Это можно сделать либо с помощью ключевого слова in, либо с помощью функции find:
s = 'My Name is Julia'
if 'Name' in s:
    print('Substring found')

index = s.find('Name')
if index != -1:
    print(f'Substring found at index {index}')



Созданные тесты нужно сохранить в файле, чтобы его было удобно запускать и хранить в системе контроля версий. Давайте создадим файл test_abs_project.py и напишем 
в нём следующий код:
def test_abs1():
    assert abs(-42) == 42, "Should be absolute value of a number" 

if __name__ == "__main__":
    test_abs1()
    print("All tests passed!")
Мы поместили тестовый сценарий в функцию для разделения тест-кейсов и возможности их независимого запуска.
Не вдаваясь в подробности, скажем только, что конструкция if __name__ == "__main__" служит для подтверждения того что данный скрипт был запущен напрямую, а не
 вызван внутри другого файла в качестве модуля. Весь код написанный в теле этого условия будет выполнен только если пользователь запустил файл самостоятельно. 


================PyTest=============================

Откройте терминал, перейдите в директорию, в которой вы работаете с автотестами, и активируйте виртуальное окружение.
После чего выполните в терминале команду:
pip freeze > requirements.txt
Эта команда сохранит все версии пакетов в специальный файл requirements.txt.
Как их оттуда достать? Попробуйте создать новое виртуальное окружение (если нужно, вернитесь в модуль 1 за инструкциями) и активировать. После чего выполните команду:
pip install -r requirements.txt
В свежем окружении все пакеты установлены одной командой!

если мы не передали никакого аргумента в команду, а написали просто pytest, тест-раннер начнёт поиск в текущей директории
как аргумент можно передать файл, путь к директории или любую комбинацию директорий и файлов, например: 
pytest scripts/selenium_scripts
# найти все тесты в директории scripts/selenium_scripts

pytest test_user_interface.py
# найти и выполнить все тесты в файле 

pytest scripts/drafts.py::test_register_new_user_parametrized
# найти тест с именем test_register_new_user_parametrized в указанном файле в указанной директории и выполнить 

дальше происходит рекурсивный поиск: то есть PyTest обойдет все вложенные директории
во всех директориях PyTest ищет файлы, которые удовлетворяют правилу  test_*.py или *_test.py (то есть начинаются на test_ или заканчиваются _test и 
имеют расширение .py)
внутри всех этих файлов находит тестовые функции по следующему правилу:
все тесты, название которых начинается с test, которые находятся вне классов
все тесты, название которых начинается с test внутри классов, имя которых начинается с Test (и без метода __init__ внутри класса)


====Fixture(фикстуры)====

Важной составляющей в использовании PyTest является концепция фикстур. Фикстуры в контексте PyTest — это вспомогательные функции для наших тестов,
 которые не являются частью тестового сценария.
Назначение фикстур может быть самым разным. Одно из распространенных применений фикстур — это подготовка тестового окружения и очистка тестового окружения
 и данных после завершения теста. 
Классический способ работы с фикстурами — создание setup- и teardown-методов в файле с тестами.

PyTest предлагает продвинутый подход к фикстурам, когда фикстуры можно задавать глобально, передавать
 их в тестовые методы как параметры, а также имеет набор встроенных фикстур. 

Мы создадим фикстуру browser, которая будет создавать объект WebDriver. Этот объект мы сможем использовать в тестах для взаимодействия с браузером.
 Для этого мы напишем метод browser и укажем, что он является фикстурой с помощью декоратора @pytest.fixture. После этого мы можем вызывать фикстуру
 в тестах, передав ее как параметр. По умолчанию фикстура будет создаваться для каждого тестового метода, то есть для каждого теста запустится
 свой экземпляр браузера.
@pytest.fixture
def browser():
    print("\nstart browser for test..")
    browser = webdriver.Chrome()
    return browser

Поэтому надо явно закрывать браузеры после каждого теста. Для этого мы можем воспользоваться финализаторами. Один из вариантов финализатора — использование
 ключевого слова Python: yield. После завершения теста, который вызывал фикстуру, выполнение фикстуры продолжится со строки, 
следующей за строкой со словом yield:
@pytest.fixture
def browser():
    print("\nstart browser for test..")
    browser = webdriver.Chrome()
    yield browser
    # этот код выполнится после завершения теста
    print("\nquit browser..")
    browser.quit()

Рекомендуем также выносить очистку данных и памяти в фикстуру, вместо того чтобы писать это в шагах теста: финализатор выполнится даже в
 ситуации, когда тест упал с ошибкой. 

Для фикстур можно задавать область покрытия фикстур. Допустимые значения: “function”, “class”, “module”, “session”. Соответственно, фикстура будет 
вызываться один раз для тестового метода, один раз для класса, один раз для модуля или один раз для всех тестов, запущенных в данной сессии. 
@pytest.fixture(scope="class") - например

При описании фикстуры можно указать дополнительный параметр autouse=True, который укажет, что фикстуру нужно запустить для каждого теста даже без явного вызова: 
@pytest.fixture(autouse=True)

=============Метки(Marks)===========

Для выборочного запуска таких тестов в PyTest используется маркировка тестов или метки (marks). Для маркировки теста нужно написать
 декоратор вида @pytest.mark.mark_name, где mark_name - произвольная строка.
 @pytest.mark.smoke
    def test_guest_should_see_login_link(self, browser): ...
Чтобы запустить тест с нужной маркировкой, нужно передать в командной строке параметр -m и нужную метку:
pytest -s -v -m smoke test_fixture8.py
Это предупреждение появилось потому, что в последних версиях PyTest настоятельно рекомендуется регистрировать метки явно перед использованием.
 Это, например, позволяет избегать опечаток, когда вы можете ошибочно пометить ваш тест несуществующей меткой, и он будет пропускаться при прогоне тестов.
Как же регистрировать метки?
Создайте файл pytest.ini в корневой директории вашего тестового проекта и добавьте в файл следующие строки:
[pytest]
markers =
    smoke: marker for smoke tests
    regression: marker for regression tests
Текст после знака ":" является поясняющим - его можно не писать.
Так же можно маркировать целый тестовый класс. В этом случае маркировка будет применена ко всем тестовым методам, входящим в класс.
==Инверсия==
Чтобы запустить все тесты, не имеющие заданную маркировку, можно использовать инверсию. Для запуска всех тестов, не отмеченных как smoke, нужно выполнить команду:
pytest -s -v -m "not smoke" test_fixture8.py
Для запуска тестов с разными метками можно использовать логическое ИЛИ. Запустим smoke и regression-тесты:
pytest -s -v -m "smoke or regression" test_fixture8.py

Предположим, у нас есть smoke-тесты, которые нужно запускать только для определенной операционной системы, например, для Windows 10. Зарегистрируем метку
 win10 в файле pytest.ini, а также добавим к одному из тестов эту метку.
pytest.ini:
[pytest]
markers =
    smoke: marker for smoke tests
    regression: marker for regression tests
    win10

@pytest.mark.smoke
@pytest.mark.win10

Чтобы запустить только smoke-тесты для Windows 10, нужно использовать логическое И:
pytest -s -v -m "smoke and win10" test_fixture81.py

Пропустить тест
Итак, чтобы пропустить тест, его отмечают в коде как @pytest.mark.skip:
В результатах теста мы увидим, что один тест был пропущен, а другой успешно прошёл: "1 passed, 1 skipped".


Отметить тест как падающий
Теперь добавим в наш тестовый класс тест, который проверяет наличие кнопки "Избранное":
Предположим, что такая кнопка должна быть, но из-за изменений в коде она пропала. Пока разработчики исправляют баг, мы хотим, чтобы результат
 прогона ﻿всех ﻿наших тестов был успешен, но падающий тест помечался соответствующим образом, чтобы про него не забыть. Добавим
 маркировку @pytest.mark.xfail для падающего теста.

Когда баг починят, мы это узнаем, ﻿﻿так как теперь тест будет отмечен как XPASS (“unexpectedly passing” - неожиданно проходит). После этого
 маркировку xfail для теста можно удалить. Кстати, к маркировке xfail можно добавлять параметр reason. Чтобы увидеть это сообщение в консоли,
 при запуске нужно добавлять параметр pytest -rx.
pytest -rx -v test_fixture10a.py
pytest -rX -v test_fixture10b.py
чтобы увидеть причины в консоли нужно запускать с флагом -rsx.


======================Параметризация тестов=====================
PyTest позволяет запустить один и тот же тест с разными входными параметрами. Для этого используется декоратор @pytest.mark.parametrize().
 Наш сайт доступен для разных языков. Напишем тест, который проверит, что для сайта с русским и английским языком будет отображаться ссылка
 на форму логина. Передадим в наш тест ссылки на русскую и английскую версию главной страницы сайта.
В @pytest.mark.parametrize() нужно передать параметр, который должен изменяться, и список значений параметра. В самом тесте наш параметр тоже
 нужно передавать в качестве аргумента. Обратите внимание, что внутри декоратора имя параметра оборачивается в кавычки, а в списке аргументов
 теста кавычки не нужны.

import pytest
from selenium import webdriver

@pytest.fixture(scope="function")
def browser():
    print("\nstart browser for test..")
    browser = webdriver.Chrome()
    yield browser
    print("\nquit browser..")
    browser.quit()

@pytest.mark.parametrize('language', ["ru", "en-gb"])
def test_guest_should_see_login_link(browser, language):
    link = f"http://selenium1py.pythonanywhere.com/{language}/"
    browser.get(link)
    browser.find_element_by_css_selector("#login_link")

Запустите тест:
pytest -s -v test_fixture7.py

Можно задавать параметризацию также для всего тестового класса, чтобы все тесты в классе запустились с заданными параметрами. В таком случае отметка
 о параметризации должна быть перед объявлением класса: 

@pytest.mark.parametrize('language', ["ru", "en-gb"])
class TestLogin(object):
    def test_guest_should_see_login_link(self, browser, language):
        link = f"http://selenium1py.pythonanywhere.com/{language}/"
        browser.get(link)
        browser.find_element_by_css_selector("#login_link")
        # этот тест запустится 2 раза

    def test_guest_should_see_navbar_element(self, browser, language):
        # этот тест тоже запустится дважды

=================Урок 3.4 Конфигурация тестов Conftest.py===================
Conftest.py - конфигурация тестов
Ранее мы добавили фикстуру browser, которая создает нам экземпляр браузера для тестов в данном файле. Когда файлов с тестами становится больше
 одного, приходится в каждом файле с тестами описывать данную фикстуру. Это очень неудобно. Для хранения часто употребимых фикстур и хранения 
глобальных настроек нужно использовать файл conftest.py, который должен лежать в директории верхнего уровня в вашем проекте с тестами.
 Можно создавать дополнительные файлы conftest.py в других директориях, но тогда настройки в этих файлах будут применяться только к 
тестам в под-директориях.
Создадим файл conftest.py в корневом каталоге нашего тестового проекта и перенесем туда фикстуру browser. Заметьте, насколько лаконичнее стал выглядеть файл с тестами.
conftest.py:

import pytest
from selenium import webdriver

@pytest.fixture(scope="function")
def browser():
    print("\nstart browser for test..")
    browser = webdriver.Chrome()
    yield browser
    print("\nquit browser..")
    browser.quit()
Теперь, сколько бы файлов с тестами мы ни создали, у тестов будет доступ к фикстуре browser. Фикстура передается в тестовый метод в качестве аргумента.
 Таким образом можно удобно переиспользовать одни и те же вспомогательные функции в разных частях проекта.
test_conftest.py:

link = "http://selenium1py.pythonanywhere.com/"

def test_guest_should_see_login_link(browser):
    browser.get(link)
    browser.find_element_by_css_selector("#login_link")

ОЧЕНЬ ВАЖНО! 
Есть одна важная особенность поведения конфигурационных файлов, о которой вы обязательно должны знать. PyTest автоматически находит и подгружает
 файлы conftest.py, которые находятся в директории с тестами. Если вы храните все свои скрипты для курса в одной директории, будьте аккуратны и 
следите, чтобы не возникало ситуации, когда вы запускаете тесты из папки tests:

tests/
├── conftest.py
├── subfolder
│   └── conftest.py
│   └── test_abs.py
следует избегать!
В таком случае применятся ОБА файла conftest.py, что может вести к непредсказуемым ошибкам и конфликтам.  

Таким образом можно переопределять разные фикстуры, но мы в рамках курса рекомендуем придерживаться одного файла на проект/задачу и держать
 их горизонтально, как-нибудь так: 

selenium_course_solutions/
├── section3
│   └── conftest.py
│   └── test_languages.py
├── section4 
│   └── conftest.py
│   └── test_main_page.py

правильно!


=================Урок 3.6 Conftest.py и передача параметров в командной строке ===================

Встроенная фикстура request может получать данные о текущем запущенном тесте, что позволяет, например, сохранять дополнительные данные в отчёт,
 а также делать многие другие интересные вещи. В этом шаге мы хотим показать, как можно настраивать тестовые окружения с помощью передачи параметров через командную строку.
Это делается с помощью встроенной функции pytest_addoption и фикстуры request. Сначала добавляем в файле conftest обработчик опции в функции pytest_addoption, 
затем напишем фикстуру, которая будет обрабатывать переданные в опции данные. Подробнее можно ознакомиться 
здесь: https://docs.pytest.org/en/latest/example/simple.html?highlight=addoption

Добавим логику обработки командной строки в conftest.py. Для запроса значения параметра мы можем вызвать команду:

browser_name = request.config.getoption("browser_name")
conftest.py:

import pytest
from selenium import webdriver

def pytest_addoption(parser):
    parser.addoption('--browser_name', action='store', default=None,
                     help="Choose browser: chrome or firefox")


@pytest.fixture(scope="function")
def browser(request):
    browser_name = request.config.getoption("browser_name")
    browser = None
    if browser_name == "chrome":
        print("\nstart chrome browser for test..")
        browser = webdriver.Chrome()
    elif browser_name == "firefox":
        print("\nstart firefox browser for test..")
        browser = webdriver.Firefox()
    else:
        raise pytest.UsageError("--browser_name should be chrome or firefox")
    yield browser
    print("\nquit browser..")
    browser.quit()

test_parser.py:

link = "http://selenium1py.pythonanywhere.com/"


def test_guest_should_see_login_link(browser):
    browser.get(link)
    browser.find_element_by_css_selector("#login_link")
Если вы теперь запустите тесты без параметра, то получите ошибку:

pytest -s -v test_parser.py
_pytest.config.UsageError: --browser_name should be chrome or firefox
Можно задать значение параметра по умолчанию, чтобы в командной строке не обязательно было указывать параметр --browser_name, например, так:

parser.addoption('--browser_name', action='store', default="chrome",
                 help="Choose browser: chrome or firefox")
Давайте укажем параметр:

pytest -s -v --browser_name=chrome test_parser.py
А теперь запустим тесты на Firefox:

pytest -s -v --browser_name=firefox test_parser.py
Вы должны увидеть, как сначала тесты запустятся в браузере Chrome, а затем -- в Firefox.


=================Урок 3.7 Перезапуск тестов ====================================

Рассмотрим еще одну проблему, с которой вы обязательно столкнетесь, когда будете писать end-to-end тесты на Selenium. Flaky-тесты или "мигающие"
 авто-тесты, т.е. такие тесты, которые по независящим от нас внешним обстоятельствам или из-за трудновоспроизводимых багов, могут иногда падать,
 хотя всё остальное время они проходят успешно. Это может происходить в момент прохождения тестов из-за одновременного обновления сайта, из-за
 сетевых проблем или странных стечений обстоятельств. Конечно, надо стараться исключать такие проблемы и искать причины возникновения багов,
 но в реальном мире бывает, что это требует слишком много усилий. Поэтому мы будем перезапускать упавший тест, чтобы еще раз убедиться, что
 он действительно нашел баг, а не упал случайно.

Это сделать очень просто. Для этого мы будем использовать плагин pytest-rerunfailures.

Сначала установим плагин в нашем виртуальном окружении. После установки плагин будет автоматически найден PyTest, и можно будет пользоваться
 его функциональностью без дополнительных изменений кода:

pip install pytest-rerunfailures==7.0
Чтобы указать количество перезапусков для каждого из упавших тестов, нужно добавить в командную строку параметр:

"--reruns n", где n - это количество перезапусков. Если при повторных запусках тесты пройдут успешно, то и прогон тестов будет считаться
 успешным. Количество перезапусков отображается в отчёте, благодаря чему можно позже анализировать проблемные тесты.﻿﻿
Дополнительно мы указали параметр "--tb=line", чтобы сократить лог с результатами теста. Можете почитать подробнее про настройку вывода
 в документации PyTest:

pytest -v --tb=line --reruns 1 --browser_name=chrome test_rerun.py


=================Урок 3.7 Запуск автотестов для разных языков интерфейса =================================
Мы уже запускали автотесты для разных языков в одном из предыдущих шагов, используя параметризацию с помощью разных ссылок, но такой подход
 сложно масштабировать на большое количество тестов. Давайте сделаем так, чтобы сервер сам решал, какой язык интерфейса нужно отобразить, 
основываясь на данных браузера. Браузер передает данные о языке пользователя через запросы к серверу, указывая в Headers (заголовке запроса)
 параметр accept-language. Если сервер получит запрос с заголовком {accept-language: ru, en}, то он отобразит пользователю русскоязычный 
интерфейс сайта. Если русский язык не поддерживается, то будет показан следующий язык из списка, в данном случае пользователь увидит 
англоязычный интерфейс. Это, кстати, примерно то же самое, что и выставить предпочтительный язык в настройках своего браузера.

Чтобы указать язык браузера с помощью WebDriver, используйте класс Options и метод add_experimental_option, как указано в примере ниже:

from selenium.webdriver.chrome.options import Options

options = Options()
options.add_experimental_option('prefs', {'intl.accept_languages': user_language})
browser = webdriver.Chrome(options=options)

Для Firefox объявление нужного языка будет выглядеть немного иначе:

fp = webdriver.FirefoxProfile()
fp.set_preference("intl.accept_languages", user_language)
browser = webdriver.Firefox(firefox_profile=fp)
В конструктор webdriver.Chrome или webdriver.Firefox вы можете добавлять разные аргументы, расширяя возможности тестирования ваших
 веб-приложений: можно указывать прокси-сервер для контроля сетевого трафика или запускать разные версии браузера, указывая локальный
 путь к файлу браузера. Предполагаем, что эти возможности вам понадобятся позже и вы сами сможете найти настройки для этих задач.




много пропустил=================



====================================================================4.2.9=====================
base_page.py - тут мы храним методы которые применяются по всему проекту вообще, всё завернуто в класс, чтобы было удобно импортировать.

locators.py - тут мы храним локаторы, в виде констант. Локаторы каждой отдельной страницы завёрнуты в класс, чтобы было удобно импортировать

main_page.py - тут мы храним методы по конкретной странице, завернутые в класс этой странице. Класс этот - условный MainPage - наследник класса BasePage, чтобы можно было пользоваться методами, описанными в base_page.py

И вот тут ступор. Файл test_main_page.py - тут мы выполняем сами тесты? по префиксу "test_" я понимаю что это для PyTest. Тут вызванные функции будут запускаться.

Здесь мы будем создавать функции, которым:

выдаём нужный для проверки линк
созаём в функции переменную page, которой передаём браузер из base_page.py(класс BasePage) и линк из шага №1
следом говорим "page, откройся", но методом из base_page.py(класс BasePage)
добавляем проверки, которые создавали методами в main_page.py







